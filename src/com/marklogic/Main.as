/* ----------------------------------------------------------------------	Copyright 2002-2010 MarkLogic Corporation.  All Rights Reserved.---------------------------------------------------------------------- */package com.marklogic {		import flash.display.MovieClip;	import flash.display.Sprite;	import flash.external.*;	import flash.utils.Timer;	import flash.events.TimerEvent;	import flash.system.Security;	import flash.utils.setTimeout;	import com.morderdesign.net.ServerDelegate;	import com.morderdesign.net.ServerRequest;	import com.morderdesign.events.ServerRequestEvent;	import com.morderdesign.utils.Utilities;	import com.marklogic.interfaces.IListManager;	import com.marklogic.events.CoocListEvent;	import com.marklogic.controls.FilterBox;	import com.marklogic.core.Preferences;		import com.marklogic.views.CoocListManager;	import flash.display.LoaderInfo;				public class Main extends MovieClip{				// Constants:		// Public Properties:		// Private Properties:		public var list:IListManager;		protected var _serverRequest:ServerRequest;		protected var _filtered:Object;		protected var indicator:MovieClip;		protected var timer:Timer;				// Initialization:		public function Main() {			Security.allowDomain("*");			ExternalInterface.addCallback("newSearch", newSearch);			ExternalInterface.addCallback("newConstraint", newConstraint);			stage.align = 'tl';			stage.scaleMode = 'noScale';			var flashVars:Object = LoaderInfo(this.root.loaderInfo).parameters;				// comment for live site;			/* Uncomment the "flashVars" lines below for local testing			flashVars.fontName = 'Arial';			flashVars.secondaryColor = 0xA00132;			flashVars.primaryColor = 0x700023;			flashVars.filtering = 'true';			*/			//			Preferences.serverURL = (flashVars.serverURL) ? flashVars.serverURL : Preferences.serverURL ;			Preferences.primaryColor = (flashVars.primaryColor) ? uint(flashVars.primaryColor) : Preferences.primaryColor;			Preferences.secondaryColor = (flashVars.secondaryColor) ? uint(flashVars.secondaryColor) : Preferences.secondaryColor;			Preferences.filtering = (flashVars.filtering) ? ((flashVars.filtering == 'true') ? true : false)  : Preferences.filtering;			Preferences.fontName = (flashVars.fontName) ? flashVars.fontName : Preferences.fontName;			//			ServerDelegate.applicationURL = Preferences.serverURL;					createList();			//newSearch('','treatment','disease','10','1'); // <-- uncomment for local testing						// Added - Tells JS the widget has been loaded			ExternalInterface.call('widgetLoaded');		}				protected function createList():void {			list = new CoocListManager();			addChild(list as Sprite);			list.addEventListener(CoocListEvent.ITEM_CLICK,onItemClick,false,0,true);			list.addEventListener(CoocListEvent.FILTER_CLICK,onItemClick,false,0,true);			list.addEventListener(CoocListEvent.BACK,onItemClick,false,0,true);		}				public function newSearch(p_query:String, p_lex1:String, p_lex2:String, p_results:String, p_startIndex:String):void {					_serverRequest = new ServerRequest('paired');			_serverRequest.params = {};			_filtered = {type:'lex1' , name:p_lex1+" & "+p_lex2};			/*				q = text of search			    t = type of analysis.  Should be "paired" in this case			    lex1 = id of the first lexicon to be included in co occurrence			    lex2 = id of the second lexicon to be included in co occurrence			    n = number of results to return			    s = start position	 		*/			_serverRequest.addParam('q',p_query);			_serverRequest.addParam('t','paired');			_serverRequest.addParam('lex1',p_lex1);			_serverRequest.addParam('lex2',p_lex2);			_serverRequest.addParam('n',p_results);			_serverRequest.addParam('s',p_startIndex);			list.clear();			sendRequest();		}				protected function onItemClick(p_event:CoocListEvent):void {			_serverRequest.removeParam('constraint');			var _lexType:String;			var constraintData:Object;			switch(p_event.type){				case  CoocListEvent.ITEM_CLICK:					if(p_event.ctrl){						_filtered = {};						switch(p_event.data.type){							case '_lex1':								_filtered.name = p_event.data.name;								_filtered.type = 'lex1';								_filtered.lexType = _serverRequest.params['lex1'];								_lexType = _serverRequest.params.lex1;								break;							case '_lex2':								_filtered.name = p_event.data.name;								_filtered.type = 'lex2';								_filtered.lexType = _serverRequest.params['lex2'];								_lexType = _serverRequest.params.lex2;								break;						}						ExternalInterface.call('addConstraint',_lexType,p_event.data.name);						//newConstraint('','treatment','disease',10,0,'treatment:Fever;disease:test2',p_event.data.name) // <-- uncomment for local testing						return;					} else {						_serverRequest.method = 'word';					}					/*					   q = text of search					   t = type of analysis.  Should be "word" in this case					   lex1 = id of the first lexicon to be included in co occurrence					   lex2 = id of the second lexicon to be included in co occurrence					   n = number of results to return					   s = start position					*/					_serverRequest.addParam('t',_serverRequest.method);					_serverRequest.addParam('item',p_event.data.item); // keep for animation!					switch(p_event.data.type){						case '_lex1':							_serverRequest.addParam('lex1word',p_event.data.name);							_serverRequest.removeParam('lex2word');							break;						case '_lex2':							_serverRequest.addParam('lex2word',p_event.data.name);							_serverRequest.removeParam('lex1word');							break;					}					sendRequest();					break;				case CoocListEvent.BACK:					constraintData = list.getFilterData(list.currentIndex-1);					if (constraintData.lex1.length > 0 || constraintData.lex2.length > 0) {						removeConstraint(constraintData);					}					list.gotoDataSet(list.currentIndex-1);					break;				case CoocListEvent.FILTER_CLICK:					constraintData = list.getFilterData(p_event.data.index);					removeConstraint(constraintData);					list.gotoDataSet(p_event.data.index);					break;			}		}				public function newConstraint(p_query:String,p_lex1:String,p_lex2:String,p_results:Number,p_start:Number,p_constraint:String,p_filteredWord:String):void {			_serverRequest.removeParam('lex1word');			_serverRequest.removeParam('lex2word');			_serverRequest.method = 'paired';			_serverRequest.addParam('q',p_query);			_serverRequest.addParam('t','paired');			_serverRequest.addParam('lex1',p_lex1);			_serverRequest.addParam('lex2',p_lex2);			_serverRequest.addParam('n',p_results);			_serverRequest.addParam('s',p_start);			_serverRequest.addParam('constraint',p_constraint);						if(!_filtered) {								_filtered = {};				var arrays:Array = p_constraint.split(';');				var lex:String = (arrays[0].indexOf(p_filteredWord) != -1) ? (arrays[0].split(':')[0]) : (arrays[1].split(':')[0]) ;				var _type:String = (_serverRequest.params.lex1 == lex) ? 'lex1' : 'lex2';				_filtered.name = p_filteredWord;							_filtered.type = _type;				_filtered.lexType = lex;			}			sendRequest();					}				public function removeConstraint(p_constraintData:Object):void {			ExternalInterface.call('removeConstraint',p_constraintData);		}						protected function sendRequest():void {			// Show the load indicator on screen			showIndicator();						_serverRequest.addEventListener(ServerRequestEvent.COMPLETE,onDataLoaded,false,0,true);			ServerDelegate.addRequest(_serverRequest);		}		// Public Methods:		// Protected Methods:		protected function onDataLoaded(p_event:ServerRequestEvent):void {			var xml:XML = new XML(p_event.source);			var _item:Sprite;			try {				_item = _serverRequest.params.item;			}catch(e:*) {}			if(_serverRequest.method == 'paired' && _filtered) {				var filterItem:FilterBox = new FilterBox(Utilities.cloneObject(_filtered));			}			_filtered = null;			list.addDataSet(xml,(_serverRequest.method == 'word') ? 'singleMode' : 'doubleMode',_item,filterItem);						// Clear the load indicator from the screen			hideIndicator();					}				protected function showIndicator():void {			timer = new Timer(20);			indicator = new Indicator();			indicator.x = 375;			indicator.y = 162;			indicator.scaleX = indicator.scaleY =  0.5;			addChild(indicator);			timer.addEventListener(TimerEvent.TIMER, updateIndicator, false, 0, true);			timer.start();		}				protected function hideIndicator():void {			timer.stop();			timer = null;			indicator.removeEventListener(TimerEvent.TIMER, updateIndicator, false);			removeChild(indicator);		}				protected function updateIndicator(e:TimerEvent):void {			indicator.rotation += 10;		}					}	}