// ** AUTO-UI IMPORT STATEMENTS **// ** END AUTO-UI IMPORT STATEMENTS **/* ----------------------------------------------------------------------	Copyright 2002-2010 MarkLogic Corporation.  All Rights Reserved.---------------------------------------------------------------------- */package com.marklogic.controls {		import flash.display.Sprite;	import flash.text.TextField;	import flash.geom.Point;	import flash.events.MouseEvent;	import com.caurina.transitions.Tweener;	public class Tooltip extends Sprite {			public static var _instance:Tooltip;		private static var PADDING:Number = 10;		protected var flipped:Boolean = false;				// Static Accessors		public static function show(p_text:String, p_props:Object=null):void {getInstance().iShow(p_text, p_props); }		public static function hide():void { getInstance().iHide(); }		public static function getInstance():Tooltip {			return _instance;		}		public static function get visible():Boolean {			return getInstance().showing;		}				// Class		// Props		public var showing:Boolean = false;		public var labelFld:TextField;		public var leftBg:Sprite;		public var rightBg:Sprite;		public var centerBg:Sprite;		public var arrow:Sprite;		public var props:Object;		public var realLabel:TextField;				// Methods		public function Tooltip() {			if (_instance == null) { _instance = this; }			visible = false;						mouseEnabled = false;			mouseChildren = false;		}					private function iShow(p_text:String, p_props:Object=null):void {			Tweener.removeTweens(this);			realLabel = new TextField();			realLabel.text = p_text;			labelFld.htmlText = p_text;			if (p_props == null) { p_props = {}; }			props = p_props;			scaleX = scaleY = 1;			draw();			scaleX = scaleY = 0;			alpha = 1;			visible = showing = true;			Tweener.addTween(this,{scaleX:1,scaleY:1,transition:'easeOutBack',time:.4})		}				private function iHide():void {			// Hide Tooltip			showing = false;			arrow.visible = true;			props = {};			stage.removeEventListener(MouseEvent.MOUSE_MOVE,moveToolTip)			Tweener.addTween(this,{scaleX:0,scaleY:0,transition:'easeInBack',time:.25})			Tweener.addTween(this,{alpha:0,transition:'easeOut',time:1})		}				private function getWidth():Number {			return (leftBg.width+centerBg.width+rightBg.width)/2;		}				private function getHeight():Number{			return leftBg.height/2;		}				private function draw():void {			// Set the Size			labelFld.width = 1000;			if (props.width == undefined) { props.width = labelFld.textWidth + 20; }			props.width = realLabel.textWidth + 25;			if (props.track == undefined) { props.track = false; }			if (props.showArrow == false){ arrow.visible = false; }	//		labelFld.width = Math.min(labelFld.textWidth+5,props.width-10);			labelFld.width = realLabel.textWidth + 25;//props.width;//labelFld.width+5;			labelFld.height = Math.floor(labelFld.textHeight + 20);	//		centerBg.width = Math.min(labelFld.textWidth+5,props.width-(leftBg.width*2));					centerBg.width = realLabel.textWidth + 20 - (leftBg.width);					//						if (props.track) {							stage.addEventListener(MouseEvent.MOUSE_MOVE,moveToolTip,false,0,true)			}			moveToolTip(null);			bringToFront();		}				private function getLocal(p_x:Number,p_y:Number):Point {			var p:Point = new Point(p_x,p_y);			p = props.target.localToGlobal(p);			return p;		}				private function moveToolTip(p_event:MouseEvent):void {			var origX:Number;			flipped = false;			var coords:Point = getLocal(props.x,props.y);			var __x:Number = origX = props.track ? stage.mouseX : coords.x;			__x = Math.max(__x, 0);			var __y:Number = props.track ? (stage.mouseY - getHeight())-5 : (coords.y-getHeight())-5;			//			if (__x + getWidth() > (stage.stageWidth-20)) { __x = (stage.stageWidth-20) - getWidth() }									if (__y  < 0) {				__y += getHeight() + arrow.height + 22;				arrow.y = 2;				arrow.rotation = 180;				//leftBg.rotation = centerBg.rotation = rightBg.rotation = 180;				flipped = true;			} else {				arrow.y = Math.round(getHeight());				leftBg.rotation = centerBg.rotation = rightBg.rotation = 0;				arrow.rotation = 0;			}			//			x = Math.round(__x);			y = Math.round(__y);			//			// Arrow X			var p:Point = new Point(origX,0);			p = this.globalToLocal(p);			arrow.x = -arrow.width/2//Math.round(Math.max(-arrow.width/2, Math.min(getWidth()-arrow.width/2, p.x - (flipped ? -arrow.width/2 :arrow.width/2))));			positionBg();			if(p_event){ p_event.updateAfterEvent(); }		}				private function positionBg():void {			var pos:Number = arrow.x - centerBg.width >> 1;			var point:Point = new Point(pos,0);			point = this.localToGlobal(point);			if(point.x-leftBg.width < 0){ pos += point.x * -1 + leftBg.width+PADDING; } // make sure the bg doesn't go < 0 ;			centerBg.x = pos;			leftBg.height = centerBg.height = rightBg.height = labelFld.textHeight + 10;			centerBg.y = leftBg.y = rightBg.y = -(centerBg.height/2)			rightBg.x = centerBg.x + centerBg.width;			leftBg.x = centerBg.x - leftBg.width - 1;			labelFld.x = leftBg.x + 5;			labelFld.y = centerBg.y + 2;			arrow.y = (flipped) ? 0 : getHeight()-1;		}				private function bringToFront():void {			parent.removeChild(this);			props.stage.addChild(this);		}	}}